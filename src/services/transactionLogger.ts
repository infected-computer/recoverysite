import { Transaction, TransactionStatus, TransactionFilter } from '../types/payment';class TransactionLogger {  private transactions: Transaction[] = [];  constructor() {    this.loadTransactions();  }  private loadTransactions() {    try {      const storedTransactions = localStorage.getItem('payment_transactions');      if (storedTransactions) {        this.transactions = JSON.parse(storedTransactions).map((t: any) => ({          ...t,          createdAt: new Date(t.createdAt),          completedAt: t.completedAt ? new Date(t.completedAt) : undefined,        }));      }    } catch (error) {      console.error('Failed to load transactions from localStorage:', error);    }  }  private saveTransactions() {    try {      localStorage.setItem('payment_transactions', JSON.stringify(this.transactions));    } catch (error) {      console.error('Failed to save transactions to localStorage:', error);    }  }  logTransaction(transaction: Transaction): void {    this.transactions.push(transaction);    this.saveTransactions();  }  getTransactions(filter?: TransactionFilter): Transaction[] {    let filtered = [...this.transactions];    if (filter) {      if (filter.status) {        filtered = filtered.filter(t => t.status === filter.status);      }      if (filter.dateFrom) {        const from = new Date(filter.dateFrom);        filtered = filtered.filter(t => t.createdAt >= from);      }      if (filter.dateTo) {        const to = new Date(filter.dateTo);        filtered = filtered.filter(t => t.createdAt <= to);      }      if (filter.minAmount) {        filtered = filtered.filter(t => t.amount >= filter.minAmount);      }      if (filter.maxAmount) {        filtered = filtered.filter(t => t.amount <= filter.maxAmount);      }    }    return filtered;  }  updateTransactionStatus(id: string, status: TransactionStatus): boolean {    const index = this.transactions.findIndex(t => t.id === id);    if (index > -1) {      this.transactions[index].status = status;      if (status === TransactionStatus.COMPLETED || status === TransactionStatus.FAILED) {        this.transactions[index].completedAt = new Date();      }      this.saveTransactions();      return true;    }    return false;  }  exportTransactions(format: 'csv' | 'json'): string {    if (format === 'json') {      return JSON.stringify(this.transactions, null, 2);    } else if (format === 'csv') {      if (this.transactions.length === 0) {        return 'ID,Amount,Currency,Status,CreatedAt,CompletedAt,PaymentMethodId,ReceiptUrl,RefundId,CustomerEmail,CustomerName';      }      const headers = 'ID,Amount,Currency,Status,CreatedAt,CompletedAt,PaymentMethodId,ReceiptUrl,RefundId,CustomerEmail,CustomerName';      const rows = this.transactions.map(t =>         `"${t.id}",${t.amount},"${t.currency}","${t.status}","${t.createdAt.toISOString()}","${t.completedAt ? t.completedAt.toISOString() : ''}","${t.paymentMethodId}","${t.receiptUrl || ''}","${t.refundId || ''}","${t.customerInfo?.email || ''}","${t.customerInfo?.name || ''}"`      ).join('
');      return `${headers}
${rows}`;    }    throw new Error('Unsupported export format');  }  getTransactionStats() {    const total = this.transactions.length;    const completed = this.transactions.filter(t => t.status === TransactionStatus.COMPLETED).length;    const pending = this.transactions.filter(t => t.status === TransactionStatus.PENDING).length;    const failed = this.transactions.filter(t => t.status === TransactionStatus.FAILED).length;    const totalAmount = this.transactions      .filter(t => t.status === TransactionStatus.COMPLETED)      .reduce((sum, t) => sum + t.amount, 0);    const averageAmount = completed > 0 ? totalAmount / completed : 0;    return {      total,      completed,      pending,      failed,      totalAmount,      averageAmount,    };  }  detectSuspiciousTransactions(): Transaction[] {    const suspicious: Transaction[] = [];    const now = new Date();    // High amount transactions    const highAmountThreshold = 1000; // Example threshold    this.transactions.forEach(t => {      if (t.amount > highAmountThreshold && t.status === TransactionStatus.COMPLETED) {        suspicious.push(t);      }    });    // Multiple failed transactions from same customer in short period    const failedAttemptsThreshold = 3;    const timeWindowMs = 5 * 60 * 1000; // 5 minutes    const failedByEmail: { [email: string]: Transaction[] } = {};    this.transactions.forEach(t => {      if (t.status === TransactionStatus.FAILED && t.customerInfo?.email) {        if (!failedByEmail[t.customerInfo.email]) {          failedByEmail[t.customerInfo.email] = [];        }        failedByEmail[t.customerInfo.email].push(t);      }    });    for (const email in failedByEmail) {      const recentFailed = failedByEmail[email].filter(t =>         (now.getTime() - t.createdAt.getTime()) < timeWindowMs      );      if (recentFailed.length >= failedAttemptsThreshold) {        suspicious.push(...recentFailed);      }    }    return [...new Set(suspicious)]; // Remove duplicates  }}export const transactionLogger = new TransactionLogger();export default transactionLogger;